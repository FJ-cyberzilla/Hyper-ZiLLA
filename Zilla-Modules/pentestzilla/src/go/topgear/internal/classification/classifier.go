package classification

import (
    "strings"
    "regexp"
    "encoding/hex"
    	"topgear/internal/discovery")

type AIClassifier struct {
    vendorDB    map[string]string
    devicePatterns map[string]*regexp.Regexp
    behavioralModels map[string]BehavioralModel
}

func NewAIClassifier() *AIClassifier {
    return &AIClassifier{
        vendorDB: loadVendorDatabase(),
        devicePatterns: loadDevicePatterns(),
        behavioralModels: loadBehavioralModels(),
    }
}

func (a *AIClassifier) ClassifyDevice(device discovery.Device) discovery.ClassifiedDevice {
    classified := discovery.ClassifiedDevice{
        ID: generateDeviceID(device),
        MACAddress: device.MAC,
        IPAddresses: device.IPs,
        Hostname: device.Hostname,
    }
    
    // Vendor identification from MAC OUI
    classified.DeviceVendor = a.identifyVendor(device.MAC)
    
    // Device type classification
    classified.DeviceType = a.classifyDeviceType(device, classified.DeviceVendor)
    
    // OS fingerprinting
    classified.OS = a.fingerprintOS(device)
    
    // Behavioral analysis
    classified.BehavioralScore = a.analyzeBehavior(device)
    
    // Threat assessment
    classified.RiskLevel = a.assessRisk(device, classified)
    classified.ThreatIndicators = a.detectThreatIndicators(device, classified)
    
    return classified
}

func (a *AIClassifier) classifyDeviceType(device discovery.Device, vendor string) string {
    // Multi-factor classification
    
    // 1. MAC address analysis
    if deviceType := a.analyzeMACPattern(device.MAC, vendor); deviceType != "" {
        return deviceType
    }
    
    // 2. Hostname analysis
    if deviceType := a.analyzeHostname(device.Hostname); deviceType != "" {
        return deviceType
    }
    
    // 3. Service fingerprinting
    if deviceType := a.analyzeServices(device.Services); deviceType != "" {
        return deviceType
    }
    
    // 4. Network behavior
    if deviceType := a.analyzeNetworkBehavior(device); deviceType != "" {
        return deviceType
    }
    
    return "unknown"
}

func (a *AIClassifier) analyzeMACPattern(mac, vendor string) string {
    mac = strings.ToLower(mac)
    
    // Samsung devices
    if strings.Contains(vendor, "Samsung") {
        if matched, _ := regexp.MatchString(`([0-9a-f]{2}:){5}[0-9a-f]{2}`, mac); matched {
            // Analyze MAC patterns for Samsung device types
            if strings.HasPrefix(mac, "aa:bb:cc") { // Example pattern
                return "phone"
            }
        }
    }
    
    // Apple devices
    if strings.Contains(vendor, "Apple") {
        // iPhones, iPads, MacBooks, Apple Watches have specific OUI patterns
        if strings.HasPrefix(mac, "00:1b:63") || strings.HasPrefix(mac, "00:1d:4f") {
            return "phone"
        }
        if strings.HasPrefix(mac, "00:03:93") || strings.HasPrefix(mac, "00:05:02") {
            return "laptop"
        }
        if strings.HasPrefix(mac, "00:0a:27") {
            return "watch"
        }
    }
    
    return ""
}

func (a *AIClassifier) analyzeHostname(hostname string) string {
    hostname = strings.ToLower(hostname)
    
    patterns := map[string]string{
        `-android-?[a-f0-9]+`: "phone",
        `iphone`: "phone",
        `ipad`: "tablet",
        `macbook`: "laptop",
        `surface`: "laptop",
        `thinkpad`: "laptop",
        `galaxy.*tab`: "tablet",
        `watch`: "watch",
        `raspberrypi`: "iot",
        `nest-`: "iot",
        `echo`: "iot",
    }
    
    for pattern, deviceType := range patterns {
        if matched, _ := regexp.MatchString(pattern, hostname); matched {
            return deviceType
        }
    }
    
    return ""
}

func (a *AIClassifier) analyzeServices(services []discovery.Service) string {
    servicePorts := make(map[int]bool)
    for _, service := range services {
        servicePorts[service.Port] = true
    }
    
    // Device-specific service patterns
    switch {
    case servicePorts[62078] && servicePorts[62079]: // iPhone sync
        return "phone"
    case servicePorts[3689] && servicePorts[5353]: // iTunes + mDNS
        return "laptop"
    case servicePorts[5555]: // Android ADB
        return "phone"
    case servicePorts[22] && servicePorts[5900]: // SSH + VNC
        return "laptop"
    case servicePorts[8080] && servicePorts[8443]: // Web services
        return "iot"
    }
    
    return ""
}
