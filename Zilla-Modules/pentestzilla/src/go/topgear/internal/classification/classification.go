package classification

import (
	"strings"
	"regexp"
	"time" // Added time import for ClassifiedDevice

	"topgear/internal/logger" // Added logger import
	"topgear/internal/discovery" // Import discovery for NetworkDevice and other types
)

// The functions in this file seem to provide classification and threat analysis
// which are distinct from pure discovery or Nmap scanning.
// They should be methods of a classification engine or AIClassifier.

// This function seems to be intended as a method for an AIClassifier
// It was previously a method of MXScanner, but classifies general devices.
func (a *AIClassifier) classifyDevices(devices []discovery.NetworkDevice) []discovery.ClassifiedDevice {
    var classified []discovery.ClassifiedDevice
    
    for _, device := range devices {
        classifiedDevice := discovery.ClassifiedDevice{
            NetworkDevice: device, // Embed the NetworkDevice
            Classification: "unknown", // Default
            Confidence: 0.0,
        }
        
        // Basic classification logic (from original file, adapted)
        classifiedDevice.Classification = a.classifyDeviceType(device, device.Vendor)
        // Note: Vendor and OS are already part of NetworkDevice from discovery.
        // We can add a confidence score here.
        
        classified = append(classified, classifiedDevice)
    }
    
    return classified
}

// classifyDeviceType - adapted from original. Needs to be a method of AIClassifier.
func (a *AIClassifier) classifyDeviceType(device discovery.NetworkDevice, vendor string) string {
    // Basic classification logic using existing helpers (or direct implementation)
    // This could be enhanced to use 'a.devicePatterns' and 'a.behavioralModels'
    
    // Check for common vendor OUIs
    if strings.Contains(strings.ToLower(vendor), "samsung") || strings.Contains(strings.ToLower(device.Hostname), "android") {
        return "phone"
    }
    if strings.Contains(strings.ToLower(vendor), "apple") && (strings.Contains(strings.ToLower(device.Hostname), "mac") || strings.Contains(strings.ToLower(device.OS), "mac")) {
        return "laptop" 
    }
    // More rules can be added here
    
    return "unknown"
}


// analyzeThreats - adapted from original file, now a method of AIClassifier
func (a *AIClassifier) analyzeThreats(devices []discovery.ClassifiedDevice) *discovery.ThreatAssessment {
    assessment := &discovery.ThreatAssessment{
        TotalDevices: len(devices),
        HighRiskDevices: 0,
        Alerts: make([]string, 0),
        Recommendations: make([]string, 0),
    }
    
    for _, device := range devices {
        // Simple risk assessment (could be more complex using a.behavioralModels)
        if strings.ToLower(device.RiskLevel) == "high" { // Assuming RiskLevel is populated
            assessment.HighRiskDevices++
            assessment.Alerts = append(assessment.Alerts, fmt.Sprintf("High risk classified device: %s (%s)", device.Hostname, device.IPAddress))
        }
    }

    if assessment.HighRiskDevices > 0 {
        assessment.Recommendations = append(assessment.Recommendations, 
            "Investigate high risk classified devices", 
            "Review classification rules for accuracy")
    }
    
    return assessment
}


// The following helper functions were originally standalone in classification.go
// and seem to be classification-related utilities. I will move them to classifier.go
// or integrate them directly into the AIClassifier's methods.
// For now, I'm adapting them here as standalone functions if they're not part of AIClassifier methods.

// generateDeviceID (moved to classifier.go or directly integrated)
func generateDeviceID(mac string) string {
    return "dev-" + strings.ReplaceAll(mac, ":", "")
}

// identifyVendor (moved to classifier.go or directly integrated)
func identifyVendor(mac string) string {
    // This logic is redundant with discovery.lookupMACVendor and AIClassifier's vendorDB.
    // Should be integrated into AIClassifier.
    return "Unknown (placeholder)"
}

// fingerprintOS (moved to classifier.go or directly integrated)
func fingerprintOS(device discovery.NetworkDevice) string {
    // This logic is redundant with Nmap OS detection.
    // Should be integrated into AIClassifier if needed for non-Nmap scenarios.
    return "Unknown (placeholder)"
}

// assessRisk (moved to classifier.go or directly integrated)
func assessRisk(device discovery.ClassifiedDevice) string {
    // This logic is redundant with NetworkDevice.RiskLevel and AIClassifier's analyzeThreats.
    // Should be integrated into AIClassifier.
    return "Low (placeholder)"
}