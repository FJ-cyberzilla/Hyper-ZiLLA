package analyzer

import (
        "fmt"
        "strings"
        "topgear/internal/discovery" // Updated import
        "topgear/internal/logger"
)

type ThreatAnalyzer struct{}

func New() *ThreatAnalyzer {
        return &ThreatAnalyzer{}
}

// Analyze now accepts discovery.ReconResults for comprehensive analysis
func (a *ThreatAnalyzer) Analyze(results *discovery.ReconResults) []Vulnerability {
        var vulnerabilities []Vulnerability

        if results == nil {
                logger.Error.Println("Analyze received nil ReconResults")
                return nil
        }

        // Analyze each discovered device
        for _, device := range results.Devices {
                // Analyze services found on the device
                for _, service := range device.Services {
                        risk, description, remediation := a.analyzeService(device.IPAddress, service)
                        vulnerabilities = append(vulnerabilities, Vulnerability{
                                Type:        fmt.Sprintf("Open Service: %s/%s", service.Name, service.Protocol),
                                Risk:        risk,
                                Description: description,
                                Remediation: remediation,
                                Component:   a.getServiceComponent(service.Name),
                                Reference:   a.getServiceReference(service.Name),
                                Target:      device.IPAddress,
                        })
                }

                // Include Nmap-reported vulnerabilities directly
                for _, nmapVuln := range device.Vulnerabilities {
                        vulnerabilities = append(vulnerabilities, Vulnerability{
                                Type:        fmt.Sprintf("Nmap Vulnerability: %s", nmapVuln.ID),
                                Risk:        nmapVuln.Risk,
                                Description: nmapVuln.Description,
                                Remediation: nmapVuln.Remediation,
                                Component:   nmapVuln.Component,
                                Reference:   nmapVuln.Reference,
                                Target:      device.IPAddress,
                        })
                }

                // Analyze system-level aspects of the device
                sysVulns := a.analyzeDeviceSystem(device)
                vulnerabilities = append(vulnerabilities, sysVulns...)
        }

        // Analyze overall network topology
        if results.NetworkInfo != nil {
                netVulns := a.analyzeNetworkTopology(results.NetworkInfo)
                vulnerabilities = append(vulnerabilities, netVulns...)
        }

        return vulnerabilities
}
// analyzeService analyzes individual services found on a device
func (a *ThreatAnalyzer) analyzeService(ip string, service discovery.Service) (string, string, string) {
	// This can be enhanced with more sophisticated rule-based analysis or integration with CVE databases.
	// For now, it's a basic placeholder based on common insecure services.
	switch strings.ToLower(service.Name) {
	case "ftp":
		return "High", fmt.Sprintf("FTP service (%d/tcp) exposed on %s. Often transmits credentials in cleartext.", service.Port, ip), "Disable FTP or migrate to SFTP/FTPS"
	case "telnet":
		return "Critical", fmt.Sprintf("Telnet service (%d/tcp) exposed on %s. Transmits all data, including credentials, in cleartext. Highly insecure.", service.Port, ip), "Immediately disable Telnet, use SSH instead"
	case "ssh":
		if service.Version == "" {
			return "Medium", fmt.Sprintf("SSH service (%d/tcp) exposed on %s. Version not detected, may indicate outdated software.", service.Port, ip), "Ensure SSH is running a recent version and configured with strong ciphers and key-based authentication."
		}
		// More sophisticated checks would go here (e.g., weak ciphers, old versions)
		return "Low", fmt.Sprintf("SSH service (%d/tcp) exposed on %s. Version: %s", service.Port, ip, service.Version), "Ensure strong authentication (key-based), disable password auth, keep software updated."
	case "http":
		return "Low", fmt.Sprintf("HTTP web service (%d/tcp) exposed on %s. Consider HTTPS for sensitive traffic.", service.Port, ip), "Implement HTTPS redirect, use security headers, conduct web application security testing."
	case "https":
		return "Low", fmt.Sprintf("HTTPS web service (%d/tcp) exposed on %s.", service.Port, ip), "Ensure TLS 1.2+, valid certificate, secure ciphers, and conduct web application security testing."
	case "smb", "microsoft-ds":
		return "High", fmt.Sprintf("SMB/Microsoft-DS service (%d/tcp) exposed on %s. Often targeted for vulnerabilities (e.g., EternalBlue).", service.Port, ip), "Disable SMB if not needed, update to latest patched versions, restrict access to trusted networks."
	default:
		if service.Port <= 1024 && service.Port != 80 && service.Port != 443 { // Well-known ports not explicitly handled
			return "Medium", fmt.Sprintf("Unknown well-known service (%d/%s) exposed on %s. Investigate its purpose and security implications.", service.Port, service.Protocol, ip), "Investigate service purpose, restrict access, apply principle of least privilege."
		}
		return "Info", fmt.Sprintf("Service (%d/%s - %s) exposed on %s.", service.Port, service.Protocol, service.Name, ip), "Investigate service purpose and ensure it is securely configured."
	}
}

func (a *ThreatAnalyzer) getServiceComponent(serviceName string) string {
	switch strings.ToLower(serviceName) {
	case "ftp", "smb", "microsoft-ds":
		return "File/Data Transfer"
	case "ssh", "telnet":
		return "Remote Access"
	case "http", "https":
		return "Web Service"
	case "dns":
		return "Network Service"
	default:
		return "General Network Service"
	}
}

func (a *ThreatAnalyzer) getServiceReference(serviceName string) string {
	switch strings.ToLower(serviceName) {
	case "ftp", "telnet":
		return "CWE-319: Cleartext Transmission of Sensitive Information"
	case "ssh":
		return "CIS SSH Benchmark, OWASP Top 10"
	case "http", "https":
		return "OWASP Top 10, TLS Best Practices"
	case "smb", "microsoft-ds":
		return "CVE-2017-0144 (EternalBlue) and related SMB vulnerabilities"
	default:
		return "N/A"
	}
}

// analyzeDeviceSystem analyzes system-level aspects of a discovered device
func (a *ThreatAnalyzer) analyzeDeviceSystem(device discovery.NetworkDevice) []Vulnerability {
	var vulns []Vulnerability

	if strings.Contains(strings.ToLower(device.OS), "android") || strings.Contains(strings.ToLower(device.DeviceType), "tablet") || strings.Contains(strings.ToLower(device.DeviceType), "phone") {
		vulns = append(vulns, Vulnerability{
			Type:        "Mobile Device Detection",
			Risk:        "Info",
			Description: fmt.Sprintf("Device %s (%s) identified as a mobile device. Mobile devices often require specific security considerations.", device.Hostname, device.IPAddress),
			Remediation: "Ensure device encryption, regular OS/app updates, review app permissions, use a strong screen lock.",
			Component:   "Operating System/Device Type",
			Reference:   "OWASP Mobile Security Testing Guide, Android Security Guidelines",
			Target:      device.IPAddress,
		})
	}

	if device.OS == "" {
		vulns = append(vulns, Vulnerability{
			Type:        "OS Detection Uncertainty",
			Risk:        "Low",
			Description: fmt.Sprintf("Operating System not clearly identified for %s (%s). This may hinder accurate vulnerability assessment.", device.Hostname, device.IPAddress),
			Remediation: "Perform further manual OS fingerprinting or use more aggressive Nmap scans.",
			Component:   "OS Detection",
			Reference:   "Nmap OS Detection",
			Target:      device.IPAddress,
		})
	} else if strings.Contains(strings.ToLower(device.OS), "windows xp") || strings.Contains(strings.ToLower(device.OS), "windows 7") {
		vulns = append(vulns, Vulnerability{
			Type:        "End-of-Life OS Detected",
			Risk:        "Critical",
			Description: fmt.Sprintf("End-of-Life operating system '%s' detected on %s (%s). This system is no longer receiving security updates and is highly vulnerable.", device.OS, device.Hostname, device.IPAddress),
			Remediation: "Immediately upgrade or decommission the system. Isolate from critical networks.",
			Component:   "Operating System",
			Reference:   "Vendor EOL Notices",
			Target:      device.IPAddress,
		})
	}
	// Add more system-level analysis rules here (e.g., detecting known vulnerable OS versions, unpatched systems)

	return vulns
}

// analyzeNetworkTopology assesses risks related to the overall network structure
func (a *ThreatAnalyzer) analyzeNetworkTopology(netInfo *discovery.NetworkInfo) []Vulnerability {
        var vulns []Vulnerability

        if netInfo.TotalDevices > 0 {		vulns = append(vulns, Vulnerability{
			Type:        "Network Discovery Complete",
			Risk:        "Info",
			Description: fmt.Sprintf("Discovered %d devices on network %s. Comprehensive network visibility is crucial for security.", netInfo.TotalDevices, netInfo.Subnet),
			Remediation: "Regularly audit network topology and device inventory.",
			Component:   "Network Topology",
			Reference:   "NIST Cybersecurity Framework",
			Target:      "Network",
		})
	}
	// Add rules for subnet analysis, open wireless APs, etc.

	return vulns
}

type Vulnerability struct {
	Type        string
	Risk        string
	Description string
	Remediation string
	Component   string
	Reference   string
	Target      string // Added to specify which device the vulnerability applies to
}
