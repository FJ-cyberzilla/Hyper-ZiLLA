package discovery

import (
	"fmt"
	"os/exec"
	"runtime"
	"strings"
	"time"

	"topgear/internal/logger"
)

// scanBluetoothClassic performs Bluetooth Classic scanning.
// It returns discovered BluetoothDevice instances or an error.
func scanBluetoothClassic() ([]BluetoothDevice, error) {
	var devices []BluetoothDevice

	if !checkBluetooth() {
		logger.Warning.Println("Bluetooth Classic scanning skipped: bluetoothctl not available.")
		return devices, nil // Not an error, just unavailable
	}

	switch runtime.GOOS {
	case "linux", "android":
		// Start Bluetooth discovery
		cmd := exec.Command("bluetoothctl", "scan", "on")
		if err := cmd.Run(); err != nil {
			logger.Error.Printf("Failed to start bluetoothctl scan: %v", err)
			return devices, fmt.Errorf("failed to start bluetooth scan: %w", err)
		}
		
		// Wait for devices to be discovered
		time.Sleep(8 * time.Second) // Increased sleep time for better discovery chance
		
		// Stop scanning
		cmd = exec.Command("bluetoothctl", "scan", "off")
		if err := cmd.Run(); err != nil {
			logger.Warning.Printf("Failed to stop bluetoothctl scan cleanly: %v", err)
			// Continue attempting to get devices even if stop fails
		}

		// Get discovered devices
		cmd = exec.Command("bluetoothctl", "devices")
		output, err := cmd.Output()
		if err != nil {
			return devices, fmt.Errorf("failed to get bluetooth devices: %w", err)
		}

		lines := strings.Split(string(output), "\n")
		for _, line := range lines {
			line = strings.TrimSpace(line)
			if line == "" || !strings.HasPrefix(line, "Device") {
				continue
			}

			parts := strings.SplitN(line, " ", 3) // Split into "Device", MAC, Name
			if len(parts) >= 3 {
				devices = append(devices, BluetoothDevice{
					Address:   parts[1],
					Name:      parts[2],
					Type:      "Classic",
					LastSeen:  time.Now(),
				})
			}
		}

	case "darwin":
		logger.Warning.Println("macOS Bluetooth discovery is basic and requires manual parsing of system_profiler output. Only paired devices might be listed accurately.")
		cmd := exec.Command("system_profiler", "SPBluetoothDataType")
		output, err := cmd.Output()
		if err != nil {
			return devices, fmt.Errorf("failed to run system_profiler SPBluetoothDataType: %w", err)
		}

		lines := strings.Split(string(output), "\n")
		var currentDevice BluetoothDevice
		for _, line := range lines {
			line = strings.TrimSpace(line)
			if strings.HasPrefix(line, "Address:") {
				if currentDevice.Address != "" { // Save previous device if any
					devices = append(devices, currentDevice)
				}
				parts := strings.SplitN(line, ":", 2)
				if len(parts) >= 2 {
					currentDevice = BluetoothDevice{
						Address: strings.TrimSpace(parts[1]),
						Type:    "Classic",
						LastSeen: time.Now(),
					}
				}
			} else if strings.HasPrefix(line, "Name:") && currentDevice.Address != "" {
				parts := strings.SplitN(line, ":", 2)
				if len(parts) >= 2 {
					currentDevice.Name = strings.TrimSpace(parts[1])
				}
			}
		}
		if currentDevice.Address != "" { // Add the last parsed device
			devices = append(devices, currentDevice)
		}

	default:
		return devices, fmt.Errorf("Bluetooth Classic scanning is not supported on %s", runtime.GOOS)
	}

	return devices, nil
}

// scanBluetoothLE performs Bluetooth Low Energy scanning. (Placeholder for advanced implementation)
func scanBluetoothLE() ([]BluetoothDevice, error) {
	logger.Warning.Println("Bluetooth LE scanning is not yet implemented. Requires specific BLE libraries/system tools.")
	return []BluetoothDevice{}, nil
}

// enumerateBluetoothServices attempts to enumerate services for discovered Bluetooth devices. (Placeholder)
func enumerateBluetoothServices(device BluetoothDevice) ([]string, error) {
	logger.Warning.Printf("Bluetooth service enumeration not implemented for device %s (%s).", device.Name, device.Address)
	return []string{}, nil
}
