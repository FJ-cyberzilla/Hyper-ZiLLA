package discovery

import (
	"fmt"
	"net"
	"os/exec"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"time"

	"topgear/internal/logger"
)

func NewNmapScanner() *NmapScanner {
	return &NmapScanner{
		InterfaceName: getDefaultInterface(),
		Timeout:       300, // 5 minutes
		Intensity:     4,   // Aggressive scanning (T4)
	}
}

// ComprehensiveScan performs a full Nmap scan including host discovery, port scanning,
// service detection, OS detection, and basic vulnerability scanning.
func (n *NmapScanner) ComprehensiveScan(target string) (*NmapResults, error) {
	logger.Info.Printf("ðŸš€ Starting enterprise-grade Nmap reconnaissance on %s...\n", target)
	logger.Info.Printf("ðŸ“¡ Using interface: %s | Intensity: T%d\n", n.InterfaceName, n.Intensity)

	var allHosts []NmapHost
	var rawOutputBuffer strings.Builder

	// Phase 1: Host Discovery
	logger.Info.Println("ðŸ” Phase 1: Host Discovery")
	liveHosts, err := n.discoverLiveHosts(target)
	if err != nil {
		logger.Error.Printf("Nmap host discovery failed for %s: %v", target, err)
		return nil, fmt.Errorf("host discovery failed: %w", err)
	}
	if len(liveHosts) == 0 {
		logger.Warning.Printf("No live hosts discovered on %s", target)
		return &NmapResults{
			Timestamp: time.Now(),
			Subnet:    target,
			Hosts:     []NmapHost{},
		},
		nil
	}

	for _, hostIP := range liveHosts {
		allHosts = append(allHosts, NmapHost{IPAddress: hostIP})
	}

	// Iterate over each live host for detailed scanning
	for i := range allHosts {
		host := &allHosts[i]
		logger.Info.Printf("ðŸŽ¯ Scanning host: %s", host.IPAddress)

		// Phase 2: Port Scanning & Service Version Detection
		logger.Info.Printf("   - Phase 2: Port Scanning and Service Version Detection for %s", host.IPAddress)
		services, err := n.scanPortsAndServices(host.IPAddress)
		if err != nil {
			logger.Error.Printf("Port and service scan failed for %s: %v", host.IPAddress, err)
			continue
		}
		host.Services = services

		// Phase 3: OS Detection
		logger.Info.Printf("   - Phase 3: OS Fingerprinting for %s", host.IPAddress)
		osInfo, err := n.detectOS(host.IPAddress)
		if err != nil {
			logger.Warning.Printf("OS detection failed for %s: %v", host.IPAddress, err)
		} else {
			host.OSInfo = *osInfo
		}

		// Phase 4: Vulnerability Script Scan
		logger.Info.Printf("   - Phase 4: Running Vulnerability Scripts for %s", host.IPAddress)
	nmapVulns, err := n.runVulnerabilityScripts(host.IPAddress)
		if err != nil {
			logger.Warning.Printf("Vulnerability script scan failed for %s: %v", host.IPAddress, err)
		} else {
			host.Vulnerabilities = nmapVulns
		}

		// Update Hostname and DeviceType based on Nmap output
		// These are often refined after detailed scans
		if host.Hostname == "" {
			host.Hostname = n.reverseDNSLookup(host.IPAddress)
		}
		if host.DeviceType == "" {
			host.DeviceType = n.extractDeviceTypeFromOSInfo(host.OSInfo.Details)
		}
	}

	return &NmapResults{
		Timestamp: time.Now(),
		Subnet:    target,
		Hosts:     allHosts,
		RawOutput: rawOutputBuffer.String(),
	},
	nil
}

// discoverLiveHosts uses Nmap's host discovery techniques.
func (n *NmapScanner) discoverLiveHosts(subnet string) ([]string, error) {
	var liveHosts []string
	cmdArgs := []string{"-sn", "-PE", "-PP", "-PS21,22,23,80,443", "-PA80,443", "-PY", fmt.Sprintf("-T%d", n.Intensity), "-n", subnet}
	cmd := exec.Command("nmap", cmdArgs...)

	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("nmap host discovery command failed: %w, output: %s", err, string(output))
	}

	re := regexp.MustCompile(`Nmap scan report for (.+)`)
	matches := re.FindAllStringSubmatch(string(output), -1)

	for _, match := range matches {
		if len(match) >= 2 {
			liveHosts = append(liveHosts, match[1])
		}
	}
	return liveHosts, nil
}

// scanPortsAndServices performs a service version detection scan on a host.
func (n *NmapScanner) scanPortsAndServices(hostIP string) ([]Service, error) {
	var services []Service
	cmdArgs := []string{"-sV", fmt.Sprintf("-T%d", n.Intensity), "-n", "--open", hostIP}
	cmd := exec.Command("nmap", cmdArgs...)

	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("nmap service scan command failed for %s: %w, output: %s", hostIP, err, string(output))
	}

	// Parse Nmap XML output for more reliable service info
	// For simplicity, using text parsing for now, but XML is recommended for robust parsing.
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		// Example: 22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4 (Ubuntu Linux; protocol 2.0)
		re := regexp.MustCompile(`^(\d+)/(\w+)\s+open\s+(\S+)\s+(.*)`)
		matches := re.FindStringSubmatch(line)
		if len(matches) > 5 {
			port, _ := strconv.Atoi(matches[1])
			services = append(services, Service{
				Port:    port,
				Protocol: matches[2],
				Name:    matches[3],
				Version: strings.TrimSpace(matches[4]),
				State:   "open",
				Timestamp: time.Now(),
			})
		}
	}
	return services, nil
}

// detectOS performs OS detection on a host.
func (n *NmapScanner) detectOS(hostIP string) (*OSInfo, error) {
	cmdArgs := []string{"-O", "--osscan-guess", fmt.Sprintf("-T%d", n.Intensity), "-n", hostIP}
	cmd := exec.Command("nmap", cmdArgs...)

	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("nmap OS detection command failed for %s: %w, output: %s", hostIP, err, string(output))
	}

	osInfo := &OSInfo{Timestamp: time.Now()}
	reOS := regexp.MustCompile(`OS details: (.*)`)
	reRunning := regexp.MustCompile(`Running: (.*)`)
	reConfidence := regexp.MustCompile(`OS.*\(([0-9.]+)%\)`) // Fixed regex

	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if matches := reOS.FindStringSubmatch(line); len(matches) > 1 {
			osInfo.Details = matches[1]
		} else if matches := reRunning.FindStringSubmatch(line); len(matches) > 1 {
			if osInfo.Details == "" { // Prefer "OS details" if available
				osInfo.Details = matches[1]
			}
		}

		if matches := reConfidence.FindStringSubmatch(line); len(matches) > 1 {
			confidence, _ := strconv.Atoi(strings.Split(matches[1], ".")[0]) // Nmap gives e.g. 99.89%, so take integer part
			osInfo.Confidence = confidence
		}
	}

	if osInfo.Details == "" {
		return nil, fmt.Errorf("no OS details found in Nmap output for %s", hostIP)
	}
	return osInfo, nil
}

// runVulnerabilityScripts executes Nmap's vuln scripts.
func (n *NmapScanner) runVulnerabilityScripts(hostIP string) ([]NmapVulnerability, error) {
	var nmapVulns []NmapVulnerability
	cmdArgs := []string{"--script", "vuln", fmt.Sprintf("-T%d", n.Intensity), "-n", hostIP}
	cmd := exec.Command("nmap", cmdArgs...)

	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("nmap vulnerability script command failed for %s: %w, output: %s", hostIP, err, string(output))
	}

	// Simple parsing for "VULNERABLE:" or specific CVEs
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.Contains(line, "VULNERABLE:") {
			reVuln := regexp.MustCompile(`VULNERABLE:\s+(.*)`)
			if matches := reVuln.FindStringSubmatch(line); len(matches) > 1 {
				nmapVulns = append(nmapVulns, NmapVulnerability{
					Title:       matches[1],
					Risk:        "High", // Default to High for script-detected vulns
					Description: "Detected by Nmap vulnerability script",
					Timestamp:   time.Now(),
					Host:        hostIP,
				})
			}
		} else if strings.Contains(line, "CVE-") {
			reCVE := regexp.MustCompile(`(CVE-\d{4}-\d{4,7})`)
			if matches := reCVE.FindStringSubmatch(line); len(matches) > 1 {
				// Avoid duplicates if already caught by "VULNERABLE:"
				found := false
				for _, v := range nmapVulns {
					if v.ID == matches[1] {
						found = true
						break
					}
				}
			if !found {
				nmapVulns = append(nmapVulns, NmapVulnerability{
					ID:          matches[1],
					Title:       matches[1],
					Risk:        "Medium", // Default, could be improved with CVE lookup
					Description: "CVE detected in Nmap output",
					Timestamp:   time.Now(),
					Host:        hostIP,
					Reference:   fmt.Sprintf("https://cve.mitre.org/cgi-bin/cvename.cgi?name=%s", matches[1]),
				})
			}
		}
		}
	}
	return nmapVulns, nil
}


// Get default network interface
func getDefaultInterface() string {
	// Dynamically detect the default interface for the current system.
	// This is a complex task and highly OS-dependent.
	// For Android/Termux, 'wlan0' is common, but may not be universal.
	// For Linux, `ip route show default | awk '{print $5}'` can often find it.
	// For cross-platform, net.Interface is needed but needs to identify "default route" interface.
	
	// Placeholder: In a truly advanced implementation, this would involve system calls
	// or Go's net package to find the interface with the default route.
	if runtime.GOOS == "linux" || runtime.GOOS == "android" {
		cmd := exec.Command("sh", "-c", "ip route show default | awk '{print $5}'")
		output, err := cmd.Output()
		if err == nil && len(output) > 0 {
			return strings.TrimSpace(string(output))
		}
	}
	
	logger.Warning.Println("Could not dynamically determine default network interface. Falling back to 'wlan0'.")
	return "wlan0" // Fallback to a common interface for Android/Linux
}

// reverseDNSLookup (moved here from network_recon.go as it's a general utility)
func (n *NmapScanner) reverseDNSLookup(ip string) string {
    names, err := net.LookupAddr(ip)
    if err == nil && len(names) > 0 {
        return strings.TrimSuffix(names[0], ".")
    }
    return ip
}

// extractDeviceTypeFromOSInfo (new helper for NmapScanner)
func (n *NmapScanner) extractDeviceTypeFromOSInfo(osDetails string) string {
	osDetailsLower := strings.ToLower(osDetails)
	if strings.Contains(osDetailsLower, "android") || strings.Contains(osDetailsLower, "mobile") {
		return "phone" // More specific classification would be in classification package
	}
	if strings.Contains(osDetailsLower, "linux") {
		return "server" // Could be more specific
	}
	if strings.Contains(osDetailsLower, "windows") {
		return "workstation" // Could be more specific
	}
	if strings.Contains(osDetailsLower, "apple") || strings.Contains(osDetailsLower, "ios") || strings.Contains(osDetailsLower, "mac os") {
		return "workstation" // Could be more specific
	}
	return "unknown"
}
