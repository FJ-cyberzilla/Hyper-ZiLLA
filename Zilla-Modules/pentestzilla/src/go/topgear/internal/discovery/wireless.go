package discovery

import (
	"fmt"
	"os/exec"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"time"

	"topgear/internal/logger"
)

// scanWiFiNetworks performs a general scan for WiFi networks (Access Points).
func scanWiFiNetworks() ([]WirelessAP, error) {
	var aps []WirelessAP

	if !checkWireless() {
		logger.Warning.Println("WiFi network scanning skipped: wireless tools not available.")
		return aps, nil // Not an error, just unavailable
	}

	switch runtime.GOOS {
	case "linux", "android":
		// Attempt to use 'iw' command for more structured output
		cmd := exec.Command("iw", "dev", "wlan0", "scan") // Assuming wlan0 is the wireless interface
		output, err := cmd.CombinedOutput()
		if err != nil {
			logger.Warning.Printf("iw scan failed, falling back to iwconfig: %v", err)
			// Fallback to iwconfig
			cmd = exec.Command("iwconfig")
			output, err = cmd.CombinedOutput()
			if err != nil {
				return aps, fmt.Errorf("failed to scan WiFi networks: %w, output: %s", err, string(output))
			}
			// Parse iwconfig output (less detailed)
			lines := strings.Split(string(output), "\n")
			for _, line := range lines {
				if strings.Contains(line, "ESSID:") {
					essid := extractESSIDFromIwconfig(line)
					if essid != "" {
						aps = append(aps, WirelessAP{SSID: essid, LastSeen: time.Now()})
					}
				}
			}
		} else {
			// Parse 'iw scan' output
			aps = parseIwScanOutput(string(output))
		}

	case "darwin":
		// macOS WiFi scan using airport utility
		cmd := exec.Command("/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport", "-s")
		output, err := cmd.CombinedOutput()
		if err != nil {
			return aps, fmt.Errorf("failed to scan WiFi networks on macOS: %w, output: %s", err, string(output))
		}
		aps = parseAirportScanOutput(string(output))

	default:
		return aps, fmt.Errorf("WiFi network scanning is not supported on %s", runtime.GOOS)
	}

	return aps, nil
}

// scanWiFiClients attempts to list WiFi clients connected to the local AP or seen in monitor mode.
func scanWiFiClients() ([]NetworkDevice, error) {
	var devices []NetworkDevice

	if !checkWireless() {
		logger.Warning.Println("WiFi client scanning skipped: wireless tools not available.")
		return devices, nil
	}

	switch runtime.GOOS {
	case "linux", "android":
		// This typically requires monitor mode and root privileges.
		// For now, a simplified approach trying to list associated stations.
		// A truly advanced implementation would use `airodump-ng` or similar.
		cmd := exec.Command("iw", "dev", "wlan0", "station", "dump") // Assuming wlan0
		output, err := cmd.CombinedOutput()
		if err != nil {
			logger.Warning.Printf("iw station dump failed for wlan0: %v. Monitor mode might be required.", err)
			return devices, nil
		}
		
		re := regexp.MustCompile(`Station ([0-9a-f:.]+)`)
		lines := strings.Split(string(output), "\n")
		for _, line := range lines {
			if matches := re.FindStringSubmatch(line); len(matches) >= 2 {
				devices = append(devices, NetworkDevice{
					MACAddress: strings.ToLower(matches[1]),
					DeviceType: "WiFi Client",
					Source:     "WiFi Scan",
					FirstSeen:  time.Now(),
					LastSeen:   time.Now(),
				})
			}
		}

	default:
		return devices, fmt.Errorf("WiFi client scanning is not supported on %s", runtime.GOOS)
	}

	return devices, nil
}

// Placeholder for Wireless AP scanning. Redundant if scanWiFiNetworks is robust.
func scanWirelessAPs() ([]WirelessAP, error) {
	logger.Warning.Println("scanWirelessAPs is redundant; use scanWiFiNetworks instead. Returning empty results.")
	return []WirelessAP{}, nil
}

// Helper to extract ESSID from iwconfig output
func extractESSIDFromIwconfig(line string) string {
	re := regexp.MustCompile(`ESSID:"([^"]+)"`) // Corrected regex to capture content within quotes
	matches := re.FindStringSubmatch(line)
	if len(matches) > 1 {
		return matches[1]
	}
	return ""
}

// Helper to parse 'iw dev wlan0 scan' output
func parseIwScanOutput(output string) []WirelessAP {
	var aps []WirelessAP
	lines := strings.Split(output, "\n")
	var currentAP WirelessAP

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "BSS ") {
			// New AP starts
			if currentAP.BSSID != "" {
				aps = append(aps, currentAP)
			}
			currentAP = WirelessAP{Timestamp: time.Now()}
			reBSSID := regexp.MustCompile(`BSS ([0-9a-f:.]+)`)
			if matches := reBSSID.FindStringSubmatch(line); len(matches) > 1 {
				currentAP.BSSID = matches[1]
			}
		} else if strings.HasPrefix(line, "SSID:") {
			currentAP.SSID = strings.TrimSpace(strings.TrimPrefix(line, "SSID:"))
		} else if strings.HasPrefix(line, "signal:") {
			reSignal := regexp.MustCompile(`signal:\s+(-?\d+)`)
			if matches := reSignal.FindStringSubmatch(line); len(matches) > 1 {
				currentAP.Signal, _ = strconv.Atoi(matches[1])
			}
		} else if strings.Contains(line, "channel:") {
			reChannel := regexp.MustCompile(`channel:\s+(\d+)`)
			if matches := reChannel.FindStringSubmatch(line); len(matches) > 1 {
				currentAP.Channel, _ = strconv.Atoi(matches[1])
			}
		} else if strings.Contains(line, "privacy") || strings.Contains(line, "authentication") {
			// Basic encryption detection
			if strings.Contains(line, "WEP") {
				currentAP.Encryption = "WEP"
			} else if strings.Contains(line, "WPA2") {
				currentAP.Encryption = "WPA2"
			} else if strings.Contains(line, "WPA") {
				currentAP.Encryption = "WPA"
			} else if strings.Contains(line, "no privacy") {
				currentAP.Encryption = "Open"
			}
		}
	}
	if currentAP.BSSID != "" { // Add the last AP
		aps = append(aps, currentAP)
	}
	return aps
}

// Helper to parse macOS 'airport -s' output
func parseAirportScanOutput(output string) []WirelessAP {
	var aps []WirelessAP
	lines := strings.Split(output, "\n")
	// Skip header line
	for i, line := range lines {
		if i == 0 || strings.TrimSpace(line) == "" {
			continue
		}
		fields := strings.Fields(line)
		if len(fields) >= 6 { // SSID, BSSID, RSSI, CHANNEL, HT, CC, SECURITY (min 6 fields)
			ssid := fields[0]
			bssid := fields[1]
			rssi, _ := strconv.Atoi(fields[2])
			channelStr := strings.Split(fields[3], ",")[0]
			channel, _ := strconv.Atoi(channelStr)

			encryption := "Unknown"
			if len(fields) > 6 {
				encryption = strings.Join(fields[6:], " ")
			} else if strings.Contains(line, "None") {
				encryption = "Open"
			}

			aps = append(aps, WirelessAP{
				SSID:       ssid,
				BSSID:      bssid,
				Signal:     rssi,
				Channel:    channel,
				Encryption: encryption,
				Timestamp:  time.Now(),
			})
		}
	}
	return aps
}
