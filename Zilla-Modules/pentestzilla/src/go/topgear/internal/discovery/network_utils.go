package discovery

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"net"
	"os/exec"
	"regexp"
	"runtime"
	"strings"
	"time"

	"topgear/internal/logger"
)

// getNetworkInterfaces returns a list of active network interface names.
func getNetworkInterfaces() ([]string, error) {
	var interfaces []string

	ifaces, err := net.Interfaces()
	if err != nil {
		return nil, fmt.Errorf("failed to get network interfaces: %w", err)
	}

	for _, iface := range ifaces {
		if iface.Flags&net.FlagUp != 0 && iface.Flags&net.FlagLoopback == 0 {
			interfaces = append(interfaces, iface.Name)
		}
	}
	if len(interfaces) == 0 {
		return nil, fmt.Errorf("no active non-loopback network interfaces found")
	}

	return interfaces, nil
}

// checkBluetooth verifies if bluetoothctl is available.
func checkBluetooth() bool {
	if runtime.GOOS == "linux" || runtime.GOOS == "android" {
		_, err := exec.LookPath("bluetoothctl")
		if err != nil {
			logger.Warning.Println("bluetoothctl not found. Bluetooth scanning will not be available.")
			return false
		}
		return true
	}
	return false
}

// checkWireless verifies if wireless tools (iwconfig/iw) are available.
func checkWireless() bool {
	if runtime.GOOS == "linux" || runtime.GOOS == "android" {
		_, err := exec.LookPath("iwconfig")
		if err != nil {
			_, err = exec.LookPath("iw")
		}
		if err != nil {
			logger.Warning.Println("Wireless tools (iwconfig/iw) not found. Wireless scanning will not be available.")
			return false
		}
		return true
	}
	return false
}

// generateScannerID creates a unique ID for the scanner instance.
func generateScannerID() string {
	bytes := make([]byte, 8)
	_, err := rand.Read(bytes)
	if err != nil {
		logger.Error.Printf("Failed to generate random bytes for scanner ID: %v", err)
		return "mxscanner-error"
	}
	return "mxscanner-" + hex.EncodeToString(bytes)
}

// scanARPTables performs ARP table scanning and returns discovered devices.
func scanARPTables() ([]NetworkDevice, error) {
	var devices []NetworkDevice

	if runtime.GOOS == "linux" || runtime.GOOS == "android" {
		cmd := exec.Command("arp", "-a")
		output, err := cmd.Output()
		if err != nil {
			return nil, fmt.Errorf("failed to run arp -a: %w", err)
		}

		lines := strings.Split(string(output), "\n")
		for _, line := range lines {
			if strings.Contains(line, "ether") {
				re := regexp.MustCompile(`(\S+)\s+\((\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\)\s+at\s+([0-9a-f:]+)`)
				matches := re.FindStringSubmatch(line)
				if len(matches) >= 4 {
					device := NetworkDevice{
						IPAddress:  matches[2],
						MACAddress: strings.ToLower(matches[3]),
						Hostname:   matches[1],
						Source:     "ARP",
						FirstSeen:  time.Now(),
						LastSeen:   time.Now(),
					}
				devices = append(devices, device)
				}
			}
		}
	} else {
		return nil, fmt.Errorf("ARP table scanning is not supported on %s", runtime.GOOS)
	}

	return devices, nil
}

// scanmDNS performs mDNS discovery. (Placeholder)
func scanmDNS() ([]NetworkDevice, error) {
	logger.Warning.Println("mDNS discovery is not yet implemented. Returning empty results.")
	return []NetworkDevice{}, nil
}

// scanSSDP performs SSDP discovery. (Placeholder)
func scanSSDP() ([]NetworkDevice, error) {
	logger.Warning.Println("SSDP discovery is not yet implemented. Returning empty results.")
	return []NetworkDevice{}, nil
}

// pingSweep performs a basic ping sweep of the local network.
func pingSweep() ([]NetworkDevice, error) {
	var devices []NetworkDevice

	localIP, err := getLocalIP()
	if err != nil {
		return nil, fmt.Errorf("failed to get local IP for ping sweep: %w", err)
	}
	if localIP == "" {
		return nil, fmt.Errorf("local IP not found, cannot perform ping sweep")
	}

	ipParts := strings.Split(localIP, ".")
	if len(ipParts) != 4 {
		return nil, fmt.Errorf("invalid local IP format: %s", localIP)
	}

	networkPrefix := strings.Join(ipParts[0:3], ".")

	// Perform a simple ping sweep (limited range for speed)
	// In a real scenario, this would be more comprehensive and concurrent.
	for i := 1; i <= 254; i++ { // Scan typical /24 subnet range
		targetIP := fmt.Sprintf("%s.%d", networkPrefix, i)
		// Use a very short timeout for ping checks to avoid hanging
		cmd := exec.Command("ping", "-c", "1", "-W", "1", targetIP) // -c 1: one packet, -W 1: 1 sec timeout
		err := cmd.Run()
		if err == nil {
			devices = append(devices, NetworkDevice{
				IPAddress: targetIP,
				Source:    "Ping Sweep",
				FirstSeen: time.Now(),
				LastSeen:  time.Now(),
			})
		}
	}

	return devices, nil
}

// Helper function to check if port is open
func isPortOpen(host string, port int) bool {
	timeout := time.Second * 1 // Shorter timeout for quick checks
	conn, err := net.DialTimeout("tcp", net.JoinHostPort(host, fmt.Sprintf("%d", port)), timeout)
	if err != nil {
		return false
	}
	defer conn.Close()
	return true
}

// Get service name from port
func getServiceName(port int) string {
	services := map[int]string{
		21: "ftp", 22: "ssh", 23: "telnet", 53: "dns",
		80: "http", 443: "https", 8080: "http-proxy",
		8443: "https-alt", 9090: "unknown",
	}
	if service, exists := services[port]; exists {
		return service
	}
	return "unknown"
}

// Get risk level for port
func getPortRisk(port int) string {
	highRisk := map[int]bool{21: true, 23: true}
	if highRisk[port] {
		return "High"
	}
	return "Medium"
}

// Get local IP address
func getLocalIP() (string, error) {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		return "", fmt.Errorf("failed to get interface addresses: %w", err)
	}

	for _, addr := range addrs {
		if ipnet, ok := addr.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
			if ipnet.IP.To4() != nil {
				return ipnet.IP.String(), nil
			}
		}
	}
	return "", fmt.Errorf("no non-loopback IPv4 address found")
}
