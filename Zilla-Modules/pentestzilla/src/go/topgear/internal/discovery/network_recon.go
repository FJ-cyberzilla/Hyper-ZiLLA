package discovery

import (
	"bufio"
	"bytes"
	"fmt"
	"net"
	"os/exec"
	"regexp"
	"runtime"
	"strings"
	"time"

	"topgear/internal/logger"
)

// Professional network reconnaissance using kernel tables and nmap
type NetworkRecon struct {
	arpTable      []ARPEntry
	neighborTable []NeighborEntry
	nmapAvailable bool
	nmapScanner   *NmapScanner // Added NmapScanner
}

func NewNetworkRecon() *NetworkRecon {
	recon := &NetworkRecon{
		nmapAvailable: checkNmap(),
		nmapScanner:   NewNmapScanner(), // Initialize NmapScanner
	}
	recon.refreshTables()
	return recon
}

// Refresh kernel tables
func (n *NetworkRecon) refreshTables() {
	n.arpTable = n.readARPTable()
	n.neighborTable = n.readNeighborTable()
}

// Read ARP table from /proc/net/arp
func (n *NetworkRecon) readARPTable() []ARPEntry {
	var entries []ARPEntry

	if runtime.GOOS == "linux" || runtime.GOOS == "android" {
		// Method 1: Read /proc/net/arp
		if data, err := exec.Command("cat", "/proc/net/arp").Output(); err == nil {
			scanner := bufio.NewScanner(bytes.NewReader(data))
			lineCount := 0
			for scanner.Scan() {
				line := scanner.Text()
				if lineCount > 0 { // Skip header
					parts := strings.Fields(line)
					if len(parts) >= 6 {
						entry := ARPEntry{
							IPAddress:  parts[0],
							HWType:     parts[1],
							Flags:      parts[2],
							MACAddress: strings.ToLower(parts[3]),
							Interface:  parts[5],
						}
					entries = append(entries, entry)
					}
				}
				lineCount++
			}
		}

		// Method 2: Use arp command
		if len(entries) == 0 {
			if data, err := exec.Command("arp", "-a").Output(); err == nil {
				lines := strings.Split(string(data), "\n")
				for _, line := range lines {
					if strings.Contains(line, "ether") {
						re := regexp.MustCompile(`(\S+)\s+ether\s+([0-9a-f:]+)`)
						matches := re.FindStringSubmatch(line)
						if len(matches) >= 3 {
							entry := ARPEntry{
									IPAddress:  matches[1],
									MACAddress: strings.ToLower(matches[2]),
							}
							entries = append(entries, entry)
						}
					}
				}
			}
		}
	}

	return entries
}

// Read neighbor table using ip neigh
func (n *NetworkRecon) readNeighborTable() []NeighborEntry {
	var entries []NeighborEntry

	if runtime.GOOS == "linux" || runtime.GOOS == "android" {
		if data, err := exec.Command("ip", "neigh", "show").Output(); err == nil {
			scanner := bufio.NewScanner(bytes.NewReader(data))
			for scanner.Scan() {
				line := scanner.Text()
				parts := strings.Fields(line)
				if len(parts) >= 5 {
					entry := NeighborEntry{
						IPAddress:  parts[0],
						MACAddress: strings.ToLower(parts[4]),
						Device:     parts[2],
						State:      parts[5],
					}
				entries = append(entries, entry)
				}
			}
		}
	}

	return entries
}

// Check if nmap is available
func checkNmap() bool {
	_, err := exec.LookPath("nmap")
	return err == nil
}

// Perform comprehensive network reconnaissance
func (n *NetworkRecon) ComprehensiveRecon() *ReconResults {
	results := &ReconResults{
		Timestamp: time.Now(),
		NetworkInfo:      &NetworkInfo{},
		ThreatAssessment: &ThreatAssessment{},
	}

	// Determine subnet for Nmap scan dynamically or use a default
	// For now, we'll use a placeholder. This will be improved in getDefaultInterface.
	targetSubnet := "192.168.1.0/24" // Placeholder

	// Phase 1: Nmap Scan
	if n.nmapAvailable {
		// Run comprehensive Nmap scan
		nmapRes, err := n.nmapScanner.ComprehensiveScan(targetSubnet)
		if err != nil {
			logger.Error.Printf("Nmap comprehensive scan failed: %v", err)
			// Proceed with other discovery methods even if Nmap fails
		} else {
			// Integrate Nmap results into NetworkDevice
			n.integrateNmapResults(results, nmapRes)
		}
	}

	// Refresh kernel tables (to get local info, even if Nmap was used)
	n.refreshTables()

	// Merge and deduplicate devices from both tables
	// This step should also merge Nmap results if any, with ARP/Neighbor table data.
	// For simplicity now, we combine them. A more robust solution would deduplicate and enrich.
	allDevices := n.mergeNetworkDevices()
	
	// Add devices from Nmap that might not be in ARP/Neighbor tables
	for _, nmapDev := range results.Devices {
		found := false
		for _, dev := range allDevices {
			if dev.IPAddress == nmapDev.IPAddress {
				found = true
				break
			}
		}
		if !found {
			allDevices = append(allDevices, nmapDev)
		}
	}


	// Enhanced device analysis (post-Nmap or standalone)
	for i := range allDevices {
		device := &allDevices[i]

		// MAC vendor lookup
		device.Vendor = n.lookupMACVendor(device.MACAddress)

		// Hostname resolution (if not already set by Nmap)
		if device.Hostname == "" || device.Hostname == device.IPAddress {
			device.Hostname = n.reverseDNSLookup(device.IPAddress)
		}

		// Service detection (if not already enhanced by Nmap)
		if len(device.Services) == 0 {
			n.detectServices(device)
		}

		// Risk assessment
		device.RiskLevel = n.assessDeviceRisk(device)
	}

	results.Devices = allDevices
	results.NetworkInfo = n.analyzeNetworkTopology(allDevices)
	results.ThreatAssessment = n.assessNetworkThreats(allDevices)

	return results
}

// integrateNmapResults maps NmapScanner's results into NetworkRecon's NetworkDevice structs.
// This is a simplified integration. A full implementation would merge data carefully
// and deduplicate devices, enriching existing ones rather than just appending.
func (n *NetworkRecon) integrateNmapResults(reconResults *ReconResults, nmapRes *NmapResults) {
	for _, nmapHost := range nmapRes.Hosts {
		device := NetworkDevice{
			IPAddress: nmapHost.IPAddress,
			MACAddress: nmapHost.MACAddress,
			Hostname: nmapHost.Hostname,
			OS: nmapHost.OSInfo.Details,
			DeviceType: nmapHost.DeviceType,
			Source: "Nmap",
			FirstSeen: time.Now(),
			LastSeen: time.Now(),
			// NmapVulnerabilities and other detailed info could be mapped here if NetworkDevice extended
		}
		for _, nmapService := range nmapHost.Services {
			device.Services = append(device.Services, Service{
				Port: nmapService.Port,
				Protocol: nmapService.Protocol,
				Name: nmapService.Name,
				Version: nmapService.Version,
				State: nmapService.State,
			})
		}
		for _, nmapVuln := range nmapHost.Vulnerabilities {
			// Mapping NmapVulnerability to a more general Vulnerability struct
			// or directly adding to ThreatAssessment.Alerts.
			// For now, adding to alerts directly for simplicity.
			if reconResults.ThreatAssessment == nil {
				reconResults.ThreatAssessment = &ThreatAssessment{}
			}
			reconResults.ThreatAssessment.Alerts = append(reconResults.ThreatAssessment.Alerts, 
				fmt.Sprintf("Nmap Vuln on %s: %s (Risk: %s)", nmapHost.IPAddress, nmapVuln.Title, nmapVuln.Risk))
		}
		reconResults.Devices = append(reconResults.Devices, device)
	}
}


// Merge devices from ARP and neighbor tables
func (n *NetworkRecon) mergeNetworkDevices() []NetworkDevice {
	deviceMap := make(map[string]NetworkDevice)

	// Add ARP table entries
	for _, arpEntry := range n.arpTable {
		if arpEntry.MACAddress != "00:00:00:00:00:00" && arpEntry.IPAddress != "" {
			device := NetworkDevice{
				IPAddress:  arpEntry.IPAddress,
				MACAddress: arpEntry.MACAddress,
				Interface:  arpEntry.Interface,
				FirstSeen:  time.Now(),
				LastSeen:   time.Now(),
				Source:     "ARP Table",
			}
			deviceMap[arpEntry.IPAddress+"_"+arpEntry.MACAddress] = device
		}
	}

	// Add neighbor table entries
	for _, neighEntry := range n.neighborTable {
		if neighEntry.MACAddress != "00:00:00:00:00:00" && neighEntry.IPAddress != "" {
			key := neighEntry.IPAddress + "_" + neighEntry.MACAddress
			if existing, exists := deviceMap[key]; exists {
				// Update existing entry
				existing.Interface = neighEntry.Device
				existing.NeighborState = neighEntry.State
				deviceMap[key] = existing
			} else {
				device := NetworkDevice{
					IPAddress:     neighEntry.IPAddress,
					MACAddress:    neighEntry.MACAddress,
					Interface:     neighEntry.Device,
					NeighborState: neighEntry.State,
					FirstSeen:     time.Now(),
					LastSeen:      time.Now(),
					Source:        "Neighbor Table",
				}
				deviceMap[key] = device
			}
		}
	}

	// Convert map to slice
	var devices []NetworkDevice
	for _, device := range deviceMap {
		devices = append(devices, device)
	}

	return devices
}

// Lookup MAC vendor using OUI database
func (n *NetworkRecon) lookupMACVendor(mac string) string {
	if len(mac) < 8 {
		return "Unknown"
	}

	oui := strings.ToUpper(mac[:8])

	// Placeholder: This should load from an external, updatable OUI database file.
	// For now, returning "Unknown" to signify no hardcoded database.
	logger.Info.Printf("MAC vendor lookup for OUI %s: currently uses no internal database. Implement external OUI lookup.", oui)
	return "Unknown"
}

// Reverse DNS lookup
func (n *NetworkRecon) reverseDNSLookup(ip string) string {
	names, err := net.LookupAddr(ip)
	if err == nil && len(names) > 0 {
		return strings.TrimSuffix(names[0], ".")
	}
	return ip
}

// Basic service detection without nmap
func (n *NetworkRecon) detectServices(device *NetworkDevice) {
	commonPorts := []int{21, 22, 23, 53, 80, 443, 993, 995, 8080, 8443}
	var services []Service

	for _, port := range commonPorts {
		// This uses the simple isPortOpen. In a production scenario,
		// this would be replaced by Nmap's comprehensive port scanning results.
		if isPortOpen(device.IPAddress, port) {
			service := Service{
				Port: port,
				Protocol: "tcp",
				Name: getServiceName(port), // Service name
				// Version and other details would come from Nmap
				Risk: getPortRisk(port),
			}
			services = append(services, service)
		}
	}

	device.Services = append(device.Services, services...)
}


// Assess device risk
func (n *NetworkRecon) assessDeviceRisk(device *NetworkDevice) string {
	riskScore := 0

	// High risk services
	for _, service := range device.Services {
		if service.Risk == "High" {
			riskScore += 3
		} else if service.Risk == "Medium" {
			riskScore += 1
		}
	}

	// Unknown device type
	if device.DeviceType == "unknown" {
		riskScore += 2
	}

	// No vendor information
	if device.Vendor == "Unknown" {
		riskScore += 1
	}

	if riskScore >= 3 {
		return "High"
	} else if riskScore >= 1 {
		return "Medium"
	}
	return "Low"
}

// Analyze network topology
func (n *NetworkRecon) analyzeNetworkTopology(devices []NetworkDevice) *NetworkInfo {
	info := &NetworkInfo{}

	// Get local network information
	// This function should be made robust to determine the local subnet
	localIP, err := getLocalIP() // Assuming getLocalIP is defined in network_utils or similar
	if err == nil && localIP != "" {
		ipParts := strings.Split(localIP, ".")
		if len(ipParts) == 4 {
			info.Subnet = strings.Join(ipParts[0:3], ".") + ".0/24"
		}
	} else {
		logger.Warning.Printf("Could not determine local IP for network topology analysis: %v", err)
	}

	info.TotalDevices = len(devices)

	// Count device types
	typeCount := make(map[string]int)
	for _, device := range devices {
		typeCount[device.DeviceType]++
	}
	info.DeviceTypes = typeCount

	return info
}

// Assess network threats
func (n *NetworkRecon) assessNetworkThreats(devices []NetworkDevice) *ThreatAssessment {
	assessment := &ThreatAssessment{}

	for _, device := range devices {
		if device.RiskLevel == "High" {
			assessment.HighRiskDevices++
			assessment.Alerts = append(assessment.Alerts,
				"High risk device: "+device.IPAddress+" ("+device.Vendor+")")
		}
	}

	if assessment.HighRiskDevices > 0 {
		assessment.Recommendations = append(assessment.Recommendations,
			"Investigate high risk devices",
			"Check network segmentation",
			"Monitor device behavior")
	}

	return assessment
}
