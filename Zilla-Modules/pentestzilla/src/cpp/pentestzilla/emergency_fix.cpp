/*
 * PENTESTZILLA - EMERGENCY HOTFIX
 * REAL SCANNER - FIXED TARGET INPUT
 */

#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <atomic>
#include <mutex>
#include <chrono>
#include <random>
#include <cstring>
#include <sstream>
#include <iomanip>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/time.h>
#include <sys/select.h>
#include <openssl/sha.h>
#include <map>
#include <fstream>
#include <csignal>

// ============ REAL COLORS ============
#define RESET   "\033[0m"
#define RED     "\033[1;31m"
#define GREEN   "\033[1;32m"
#define YELLOW  "\033[1;33m"
#define BLUE    "\033[1;34m"
#define CYAN    "\033[1;36m"
#define BOLD    "\033[1m"
#define CLEAR   "\033[2J\033[1;1H"

// ============ GLOBALS ============
std::atomic<bool> running{true};

void print_banner() {
    std::cout << CLEAR;
    std::cout << RED << R"(
╔═╗┬ ┬┌─┐┌┐┌┌─┐┬ ┬  ╔╦╗┌─┐┌┐┌┌┬┐┌─┐┬─┐
╠═╝├─┤├─┤││││  ├─┤   ║║├┤ │││ │ ├┤ ├┬┘
╩  ┴ ┴┴ ┴┘└┘└─┘┴ ┴  ═╩╝└─┘┘└┘ ┴ └─┘┴└─
    )" << RESET << "\n\n";
}

class RealScanner {
private:
    std::string target_ip;
    int scan_timeout_sec = 2; // Default timeout for connect scan
    
public:
    // Helper to parse port ranges like "1-100,8080,9000-9010"
    std::vector<int> parse_ports(const std::string& port_string) {
        std::vector<int> ports;
        std::stringstream ss(port_string);
        std::string segment;
        while(std::getline(ss, segment, ',')) {
            size_t dash_pos = segment.find('-');
            if (dash_pos == std::string::npos) {
                // Single port
                try {
                    ports.push_back(std::stoi(segment));
                } catch (...) { /* Ignore invalid */ }
            } else {
                // Port range
                try {
                    int start = std::stoi(segment.substr(0, dash_pos));
                    int end = std::stoi(segment.substr(dash_pos + 1));
                    for (int i = start; i <= end; ++i) {
                        ports.push_back(i);
                    }
                } catch (...) { /* Ignore invalid */ }
            }
        }
        // Remove duplicates and sort
        std::sort(ports.begin(), ports.end());
        ports.erase(std::unique(ports.begin(), ports.end()), ports.end());
        return ports;
    }

    bool get_target() {
        std::cout << CYAN << "╔══════════════════════════════════════════════════════════╗\n";
        std::cout << "║                    TARGET INPUT                            ║\n";
        std::cout << "╚══════════════════════════════════════════════════════════╝\n" << RESET;
        
        std::cout << "\n" << YELLOW << "Enter target to scan (IP or Hostname):\n" << RESET;
        std::cout << GREEN << "Examples:\n" << RESET;
        std::cout << "  - scanme.nmap.org (test server)\n";
        std::cout << "  - 8.8.8.8 (Google DNS)\n";
        std::cout << "  - 192.168.1.1 (local router)\n";
        std::cout << "  - example.com\n\n";
        
        std::cout << YELLOW << "Your target: " << RESET;
        std::getline(std::cin, target_ip);
        
        if(target_ip.empty()) {
            std::cout << RED << "[!] No target specified!\n" << RESET;
            return false;
        }
        
        // Resolve if not IP
        if(target_ip.find_first_not_of("0123456789.") != std::string::npos) {
            std::cout << CYAN << "[*] Resolving " << target_ip << "...\n" << RESET;
            
            struct hostent *host = gethostbyname(target_ip.c_str());
            if(!host) {
                std::cout << RED << "[!] DNS resolution failed!\n" << RESET;
                std::cout << YELLOW << "[*] Trying as direct IP...\n" << RESET;
            } else {
                char ip[INET_ADDRSTRLEN];
                inet_ntop(AF_INET, host->h_addr, ip, sizeof(ip));
                std::cout << GREEN << "[✓] Resolved to: " << ip << "\n" << RESET;
                target_ip = ip;
            }
        }
        
        std::cout << GREEN << "\n[✓] Target locked: " << target_ip << "\n" << RESET;
        return true;
    }
    
    // New function to handle scan with options
    void run_scan_with_options(const std::vector<int>& ports_to_scan, bool stealth_mode) {
        // get_target is now called inside the main loop for clarity
        // if(!get_target()) return; 

        if (stealth_mode) {
            scan_timeout_sec = 5; // Longer timeout for "stealthier" connection attempts
            std::cout << CYAN << "\n[*] Running in stealth mode (longer timeouts)..\n" << RESET;
        } else {
            scan_timeout_sec = 2; // Reset to default
        }
        
        std::cout << CYAN << "\n[*] Scanning " << ports_to_scan.size() << " ports on " << target_ip << "\n" << RESET;
        std::cout << "[*] Press Ctrl+C to stop\n\n";
        
        std::vector<int> open_ports;
        
        for(int port : ports_to_scan) {
            if (!running) break; // Allow interruption
            std::cout << "\r" << YELLOW << "[*] Testing port " << port << "..." << RESET << std::string(20, ' ') << std::flush;
            
            if(scan_port(port)) {
                open_ports.push_back(port);
                std::cout << "\r" << GREEN << "[+] Port " << std::setw(5) << port << " OPEN" << RESET << std::string(20, ' ') << "\n";
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(stealth_mode ? 200 : 50)); // Slower in stealth mode
        }
        
        // RESULTS
        std::cout << GREEN << "\n╔══════════════════════════════════════════════════════════╗\n";
        std::cout << "║                    SCAN RESULTS                              ║\n";
        std::cout << "╚══════════════════════════════════════════════════════════╝\n" << RESET;
        
        std::cout << "Target: " << target_ip << "\n";
        std::cout << "Open Ports: " << open_ports.size() << " of " << ports_to_scan.size() << "\n\n";
        
        if(!open_ports.empty()) {
            std::cout << YELLOW << "OPEN PORTS:\n" << RESET;
            std::map<int, std::string> services = {
                {21, "FTP"}, {22, "SSH"}, {23, "Telnet"}, {25, "SMTP"},
                {53, "DNS"}, {80, "HTTP"}, {110, "POP3"}, {143, "IMAP"},
                {443, "HTTPS"}, {445, "SMB"}, {3306, "MySQL"}, {3389, "RDP"},
                {5432, "PostgreSQL"}, {5900, "VNC"}, {8080, "HTTP-alt"}, {8443, "HTTPS-alt"}
            };
            
            for(int port : open_ports) {
                auto it = services.find(port);
                std::string service = (it != services.end()) ? it->second : "Unknown";
                std::cout << "  " << GREEN << "► " << RESET << "Port " << std::setw(5) << port 
                          << " - " << CYAN << service << RESET << "\n";
            }
            
            // Save to file
            std::string filename = "scan_" + target_ip + "_" + std::to_string(time(nullptr)) + ".txt";
            std::ofstream out(filename);
            out << "PentestZilla Scan Results\n";
            out << "Target: " << target_ip << "\n";
            out << "Time: " << time(nullptr) << "\n";
            out << "Open Ports: ";
            for(int port : open_ports) out << port << " ";
            out << "\n";
            out.close();
            
            std::cout << GREEN << "\n[✓] Results saved to: " << filename << "\n" << RESET;
        } else {
            std::cout << YELLOW << "[!] No open ports found\n" << RESET;
        }
        
        std::cout << YELLOW << "\nPress ENTER to continue..." << RESET;
        std::cin.get();
    }
    
    bool scan_port(int port) {
        int sock = socket(AF_INET, SOCK_STREAM, 0);
        if(sock < 0) return false;
        
        struct timeval tv;
        tv.tv_sec = scan_timeout_sec;
        tv.tv_usec = 0;
        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        
        // Non-blocking
        int flags = fcntl(sock, F_GETFL, 0);
        fcntl(sock, F_SETFL, flags | O_NONBLOCK);
        
        struct sockaddr_in addr;
        memset(&addr, 0, sizeof(addr));
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        inet_pton(AF_INET, target_ip.c_str(), &addr.sin_addr);
        
        int result = connect(sock, (struct sockaddr*)&addr, sizeof(addr));
        bool is_open = false;
        
        if(result == 0) {
            is_open = true;
        } else if(errno == EINPROGRESS) {
            fd_set fdset;
            FD_ZERO(&fdset);
            FD_SET(sock, &fdset);
            
            if(select(sock + 1, NULL, &fdset, NULL, &tv) > 0) {
                int error;
                socklen_t len = sizeof(error);
                getsockopt(sock, SOL_SOCKET, SO_ERROR, &error, &len);
                if(error == 0) is_open = true;
            }
        }
        
        close(sock);
        return is_open;
    }
    
    // Original run_scan (now calls run_scan_with_options)
    void run_scan() {
        if(!get_target()) return;
        
        std::vector<int> common_ports = {
            21, 22, 23, 25, 53, 80, 110, 143, 443, 445,
            993, 995, 1433, 3306, 3389, 5432, 5900, 8080, 8443
        };
        run_scan_with_options(common_ports, false);
    }
};

int main() {
    signal(SIGINT, [](int) {
        std::cout << "\n" << RED << "[!] Scan interrupted!\n" << RESET;
        running = false;
    });
    
    while(running) {
        print_banner();
        
        std::cout << CYAN << "╔══════════════════════════════════════════════════════════╗\n";
        std::cout << "║                    MAIN MENU                             ║\n";
        std::cout << "╠══════════════════════════════════════════════════════════╣\n";
        std::cout << "║                                                          ║\n";
        std::cout << "║  " << GREEN << "1" << RESET << " » Scan Common Ports                    ║\n";
        std::cout << "║  " << GREEN << "2" << RESET << " » Custom Port Range                   ║\n";
        std::cout << "║  " << GREEN << "3" << RESET << " » Stealth Scan                        ║\n";
        std::cout << "║  " << GREEN << "4" << RESET << " » Exit                                ║\n";
        std::cout << "║                                                          ║\n";
        std::cout << "╚══════════════════════════════════════════════════════════╝\n" << RESET;
        
        std::cout << "\n" << YELLOW << "Choice: " << RESET;
        std::string choice;
        std::getline(std::cin, choice);
        
        RealScanner scanner;
        
        if(choice == "1") {
            scanner.run_scan(); // Uses common ports, no stealth
        } else if(choice == "2") {
            std::cout << YELLOW << "\nEnter custom port range (e.g., 1-100,443,8080-8090): " << RESET;
            std::string port_input;
            std::getline(std::cin, port_input);
            std::vector<int> custom_ports = scanner.parse_ports(port_input);
            if (!custom_ports.empty()) {
                scanner.run_scan_with_options(custom_ports, false);
            } else {
                std::cout << RED << "[!] Invalid or empty port range provided.\n" << RESET;
                std::cin.get();
            }
        } else if(choice == "3") {
            std::cout << YELLOW << "\nEnter custom port range for stealth scan (e.g., 1-100,443,8080-8090) or leave empty for common ports: " << RESET;
            std::string port_input;
            std::getline(std::cin, port_input);
            std::vector<int> ports_to_scan;
            if (!port_input.empty()) {
                ports_to_scan = scanner.parse_ports(port_input);
            } else {
                ports_to_scan = {21, 22, 23, 25, 53, 80, 110, 143, 443, 445,
                                993, 995, 1433, 3306, 3389, 5432, 5900, 8080, 8443};
            }

            if (!ports_to_scan.empty()) {
                scanner.run_scan_with_options(ports_to_scan, true); // Enable stealth mode
            } else {
                std::cout << RED << "[!] Invalid or empty port range provided.\n" << RESET;
                std::cin.get();
            }
        } else if(choice == "4") {
            std::cout << GREEN << "\n[+] Shutting down...\n" << RESET;
            break;
        }
    }
    
    return 0;
}
