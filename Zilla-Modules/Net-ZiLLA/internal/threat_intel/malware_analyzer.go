package threat_intel

import (
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"hash"
	"io"
	"os"
	"regexp"
	"strings"
	"sync"
	"time"

	"net-zilla/internal/models"
)

type MalwareAnalyzer struct {
	mu sync.RWMutex
	
	// Compiled regex patterns
	jsPatterns     []compiledPattern
	shellPatterns  []compiledPattern
	genericPatterns []compiledPattern
	
	// Known malicious signatures (in production, load from database or file)
	maliciousHashes map[string]MalwareSignature
	suspiciousStrings []string
	
	// Heuristic weights
	weights map[string]int
	
	// Cache for frequent checks
	signatureCache map[string]*models.BehaviorAnalysis
}

type compiledPattern struct {
	Name        string
	Pattern     *regexp.Regexp
	Type        string
	Weight      int
	Description string
	Category    string
}

type MalwareSignature struct {
	Hash        string
	HashType    string
	Name        string
	Family      string
	Severity    string
	FirstSeen   time.Time
	LastSeen    time.Time
	Description string
}

func NewMalwareAnalyzer() *MalwareAnalyzer {
	ma := &MalwareAnalyzer{
		maliciousHashes: make(map[string]MalwareSignature),
		suspiciousStrings: make([]string, 0),
		signatureCache: make(map[string]*models.BehaviorAnalysis),
		weights: map[string]int{
			"CRITICAL": 90,
			"HIGH":     70,
			"MEDIUM":   50,
			"LOW":      30,
			"INFO":     10,
		},
	}
	
	ma.loadDetectionPatterns()
	ma.loadMaliciousSignatures()
	ma.loadSuspiciousStrings()
	
	return ma
}

func (ma *MalwareAnalyzer) loadDetectionPatterns() {
	// JavaScript patterns
	jsPatterns := []struct {
		name    string
		pattern string
		typ     string
		weight  int
		desc    string
		category string
	}{
		// Obfuscation techniques
		{
			name:    "Base64 Obfuscation with Eval",
			pattern: `eval\s*\(\s*(?:atob|unescape|decodeURIComponent)\s*\(\s*['"][A-Za-z0-9+/]+={0,2}['"]\s*\)\s*\)`,
			typ:     "Obfuscation",
			weight:  85,
			desc:    "Base64 encoded payload with eval execution",
			category: "JavaScript",
		},
		{
			name:    "String.fromCharCode Obfuscation",
			pattern: `String\.fromCharCode\s*\((?:\s*\d+\s*,){10,}`,
			typ:     "Obfuscation",
			weight:  75,
			desc:    "Character code obfuscation",
			category: "JavaScript",
		},
		
		// Malicious behaviors
		{
			name:    "Cookie Theft",
			pattern: `document\.cookie\s*(?:=|!=\s*['"]\s*)?`,
			typ:     "Credential Theft",
			weight:  90,
			desc:    "Accessing browser cookies",
			category: "JavaScript",
		},
		{
			name:    "Keylogger Detection",
			pattern: `addEventListener\s*\(\s*['"]key(?:down|press|up)['"]|onkey(?:down|press|up)\s*=`,
			typ:     "Keylogging",
			weight:  95,
			desc:    "Keyboard event listeners",
			category: "JavaScript",
		},
		{
			name:    "Form Data Hijacking",
			pattern: `addEventListener\s*\(\s*['"]submit['"]|onsubmit\s*=|\.submit\(\)`,
			typ:     "Form Hijacking",
			weight:  80,
			desc:    "Form submission interception",
			category: "JavaScript",
		},
		
		// C2 Communication
		{
			name:    "WebSocket C2",
			pattern: `new\s+WebSocket\s*\(\s*['"](?:ws|wss)://[^'"]+['"]`,
			typ:     "C2 Communication",
			weight:  85,
			desc:    "WebSocket command and control",
			category: "JavaScript",
		},
		{
			name:    "Fetch C2",
			pattern: `fetch\s*\(\s*['"](?:https?|wss?)://[^'"]+['"][^)]*\)\s*\.(?:then|catch)`,
			typ:     "C2 Communication",
			weight:  80,
			desc:    "Fetch API for C2 communication",
			category: "JavaScript",
		},
		
		// Cryptojacking
		{
			name:    "Cryptominer Detection",
			pattern: `(?i)(?:coinhive|miner|webassembly|wasm|cryptonight|monero)`,
			typ:     "Cryptomining",
			weight:  70,
			desc:    "Cryptocurrency mining script",
			category: "JavaScript",
		},
		
		// Redirects and phishing
		{
			name:    "Suspicious Redirect",
			pattern: `(?:window|document)\.location\s*(?:=|\.(?:assign|replace)\s*\(\s*)['"](?:https?|javascript):`,
			typ:     "Phishing",
			weight:  75,
			desc:    "Suspicious page redirection",
			category: "JavaScript",
		},
		
		// Iframe injection
		{
			name:    "Dynamic Iframe Injection",
			pattern: `createElement\s*\(\s*['"]iframe['"]\s*\).*src\s*=\s*['"]`,
			typ:     "Iframe Injection",
			weight:  80,
			desc:    "Dynamic iframe creation with external source",
			category: "JavaScript",
		},
	}
	
	// Shell script patterns
	shellPatterns := []struct {
		name    string
		pattern string
		typ     string
		weight  int
		desc    string
		category string
	}{
		// Reverse shells
		{
			name:    "Bash Reverse Shell",
			pattern: `bash\s+(?:-i\s+)?(?:>|&)\s*/\w+/\w+\s+\d+`,
			typ:     "Reverse Shell",
			weight:  95,
			desc:    "Bash reverse shell connection",
			category: "Shell",
		},
		{
			name:    "Netcat Reverse Shell",
			pattern: `nc\s+(?:-e\s+)?(?:\w+\s+\d+|-\w+\s+\d+)`,
			typ:     "Reverse Shell",
			weight:  90,
			desc:    "Netcat reverse shell",
			category: "Shell",
		},
		
		// Privilege escalation
		{
			name:    "SUID Bit Manipulation",
			pattern: `chmod\s+[47]\d{3}\s+`,
			typ:     "Privilege Escalation",
			weight:  85,
			desc:    "Setting SUID/SGID bits",
			category: "Shell",
		},
		{
			name:    "Sudo Exploitation",
			pattern: `sudo\s+(?:bash|sh|python|perl)\s+`,
			typ:     "Privilege Escalation",
			weight:  80,
			desc:    "Sudo command injection",
			category: "Shell",
		},
		
		// Persistence mechanisms
		{
			name:    "Cron Persistence",
			pattern: `(?:crontab\s+-e|echo\s+.*\s*>>\s*/etc/cron)`,
			typ:     "Persistence",
			weight:  75,
			desc:    "Cron job persistence",
			category: "Shell",
		},
		{
			name:    "RC Local Persistence",
			pattern: `echo\s+.*\s*>>\s*/etc/rc\.local`,
			typ:     "Persistence",
			weight:  70,
			desc:    "RC local persistence",
			category: "Shell",
		},
		
		// Data exfiltration
		{
			name:    "Data Compression and Exfiltration",
			pattern: `tar\s+.*\.(?:tar|gz|bz2)\s+.*\|\s*(?:curl|wget)`,
			typ:     "Exfiltration",
			weight:  80,
			desc:    "Data compression and exfiltration",
			category: "Shell",
		},
		
		// Dangerous commands
		{
			name:    "Filesystem Wipe",
			pattern: `rm\s+-rf\s+/(?:$|\s)`,
			typ:     "Destructive",
			weight:  100,
			desc:    "Filesystem wipe command",
			category: "Shell",
		},
		{
			name:    "Fork Bomb",
			pattern: `:\s*\(\s*\)\s*\{\s*:\s*\|\s*:\s*\&\s*\;\s*\}`,
			typ:     "DoS",
			weight:  95,
			desc:    "Fork bomb denial of service",
			category: "Shell",
		},
	}
	
	// Generic patterns for multiple languages
	genericPatterns := []struct {
		name    string
		pattern string
		typ     string
		weight  int
		desc    string
		category string
	}{
		// Command execution
		{
			name:    "System Command Execution",
			pattern: `(?:exec|system|shell_exec|passthru|proc_open|popen)\s*\(`,
			typ:     "Command Execution",
			weight:  85,
			desc:    "System command execution function",
			category: "Generic",
		},
		
		// File operations
		{
			name:    "File Write to System Locations",
			pattern: `file_put_contents\s*\(\s*['"](/etc|/var|/tmp|/root|C:\\|%SystemRoot%)`,
			typ:     "File System Manipulation",
			weight:  75,
			desc:    "Writing files to system locations",
			category: "Generic",
		},
		
		// Network connections
		{
			name:    "Raw Socket Creation",
			pattern: `fsockopen|socket_create|stream_socket_client`,
			typ:     "Network Communication",
			weight:  70,
			desc:    "Raw socket creation",
			category: "Generic",
		},
		
		// Obfuscation
		{
			name:    "Multiple Encoding Layers",
			pattern: `base64_decode\s*\(\s*(?:gzinflate|str_rot13|gzuncompress)`,
			typ:     "Multi-layer Obfuscation",
			weight:  80,
			desc:    "Multiple encoding layers for obfuscation",
			category: "Generic",
		},
		
		// Eval usage
		{
			name:    "Dynamic Code Execution",
			pattern: `eval\s*\(\s*\$\w+\s*\)|assert\s*\(`,
			typ:     "Code Injection",
			weight:  90,
			desc:    "Dynamic code execution with variables",
			category: "Generic",
		},
	}
	
	// Compile all patterns
	ma.jsPatterns = make([]compiledPattern, 0, len(jsPatterns))
	for _, p := range jsPatterns {
		if re, err := regexp.Compile(p.pattern); err == nil {
			ma.jsPatterns = append(ma.jsPatterns, compiledPattern{
				Name:        p.name,
				Pattern:     re,
				Type:        p.typ,
				Weight:      p.weight,
				Description: p.desc,
				Category:    p.category,
			})
		}
	}
	
	ma.shellPatterns = make([]compiledPattern, 0, len(shellPatterns))
	for _, p := range shellPatterns {
		if re, err := regexp.Compile(p.pattern); err == nil {
			ma.shellPatterns = append(ma.shellPatterns, compiledPattern{
				Name:        p.name,
				Pattern:     re,
				Type:        p.typ,
				Weight:      p.weight,
				Description: p.desc,
				Category:    p.category,
			})
		}
	}
	
	ma.genericPatterns = make([]compiledPattern, 0, len(genericPatterns))
	for _, p := range genericPatterns {
		if re, err := regexp.Compile(p.pattern); err == nil {
			ma.genericPatterns = append(ma.genericPatterns, compiledPattern{
				Name:        p.name,
				Pattern:     re,
				Type:        p.typ,
				Weight:      p.weight,
				Description: p.desc,
				Category:    p.category,
			})
		}
	}
}

func (ma *MalwareAnalyzer) loadMaliciousSignatures() {
	// In production, load from database, file, or threat intelligence feed
	// These are example known malicious hashes
	knownMalware := []MalwareSignature{
		{
			Hash:      "d41d8cd98f00b204e9800998ecf8427e",
			HashType:  "MD5",
			Name:      "Example Trojan",
			Family:    "Trojan.Generic",
			Severity:  "CRITICAL",
			FirstSeen: time.Now().Add(-30 * 24 * time.Hour),
			LastSeen:  time.Now(),
			Description: "Generic Trojan horse",
		},
		{
			Hash:      "da39a3ee5e6b4b0d3255bfef95601890afd80709",
			HashType:  "SHA1",
			Name:      "Example Ransomware",
			Family:    "Ransomware.Generic",
			Severity:  "CRITICAL",
			FirstSeen: time.Now().Add(-15 * 24 * time.Hour),
			LastSeen:  time.Now(),
			Description: "Generic ransomware variant",
		},
	}
	
	for _, sig := range knownMalware {
		ma.maliciousHashes[sig.Hash] = sig
	}
}

func (ma *MalwareAnalyzer) loadSuspiciousStrings() {
	// Suspicious strings that often appear in malware
	ma.suspiciousStrings = []string{
		// Common malware URLs and domains
		"pastebin.com/raw/",
		"transfer.sh/",
		"anonfile.com/",
		"tinyurl.com/",
		"bit.ly/",
		
		// Common C2 patterns
		"c2server",
		"command_and_control",
		"botnet",
		"backdoor",
		
		// Common exploit strings
		"struts2",
		"log4j",
		"spring4shell",
		"petitpotam",
		
		// Common malware names
		"emotet",
		"trickbot",
		"ryuk",
		"conti",
		"lockbit",
	}
}

func (ma *MalwareAnalyzer) AnalyzeScript(content string) *models.BehaviorAnalysis {
	if content == "" {
		return &models.BehaviorAnalysis{
			Patterns:   []models.BehavioralPattern{},
			RiskScore:  0,
			Severity:   "INFO",
			Confidence: 0,
		}
	}
	
	// Check cache first
	cacheKey := ma.generateCacheKey(content)
	if analysis, found := ma.getFromCache(cacheKey); found {
		return analysis
	}
	
	analysis := &models.BehaviorAnalysis{
		Patterns:   make([]models.BehavioralPattern, 0),
		RiskScore:  0,
		Severity:   "INFO",
		Confidence: 0,
	}
	
	// Detect script type
	scriptType := ma.detectScriptType(content)
	analysis.ScriptType = scriptType
	
	// Apply appropriate patterns
	var detectedPatterns []models.BehavioralPattern
	
	switch scriptType {
	case "JavaScript":
		detectedPatterns = ma.analyzeWithPatterns(content, ma.jsPatterns)
	case "Shell":
		detectedPatterns = ma.analyzeWithPatterns(content, ma.shellPatterns)
	default:
		detectedPatterns = ma.analyzeWithPatterns(content, ma.genericPatterns)
	}
	
	// Also apply generic patterns to all scripts
	genericDetections := ma.analyzeWithPatterns(content, ma.genericPatterns)
	detectedPatterns = append(detectedPatterns, genericDetections...)
	
	// Check for suspicious strings
	stringDetections := ma.checkSuspiciousStrings(content)
	detectedPatterns = append(detectedPatterns, stringDetections...)
	
	// Calculate entropy (high entropy can indicate obfuscation)
	entropy := ma.calculateEntropy(content)
	if entropy > 6.5 { // High entropy threshold
		detectedPatterns = append(detectedPatterns, models.BehavioralPattern{
			Name:   "High Entropy Content",
			Type:   "Obfuscation",
			Weight: 65,
			Details: fmt.Sprintf("Entropy: %.2f", entropy),
		})
	}
	
	// Check for base64 encoded payloads
	if ma.detectBase64Payload(content) {
		detectedPatterns = append(detectedPatterns, models.BehavioralPattern{
			Name:   "Base64 Encoded Payload",
			Type:   "Obfuscation",
			Weight: 70,
			Details: "Base64 encoded content detected",
		})
	}
	
	// Check for hex encoded payloads
	if ma.detectHexPayload(content) {
		detectedPatterns = append(detectedPatterns, models.BehavioralPattern{
			Name:   "Hex Encoded Payload",
			Type:   "Obfuscation",
			Weight: 60,
			Details: "Hex encoded content detected",
		})
	}
	
	analysis.Patterns = detectedPatterns
	
	// Calculate risk metrics
	analysis.RiskScore = ma.calculateRiskScore(detectedPatterns)
	analysis.Severity = ma.determineSeverity(analysis.RiskScore)
	analysis.Confidence = float64(ma.calculateConfidence(detectedPatterns))
	
	// Add metadata
	analysis.Timestamp = time.Now()
	analysis.ContentLength = int64(len(content))
	
	// Cache the result
	ma.addToCache(cacheKey, analysis)
	
	return analysis
}

func (ma *MalwareAnalyzer) analyzeWithPatterns(content string, patterns []compiledPattern) []models.BehavioralPattern {
	var detected []models.BehavioralPattern
	
	for _, pattern := range patterns {
		if matches := pattern.Pattern.FindAllString(content, -1); len(matches) > 0 {
			for _, match := range matches {
				// Limit match length for display
				matchDisplay := match
				if len(matchDisplay) > 100 {
					matchDisplay = matchDisplay[:97] + "..."
				}
				
				detected = append(detected, models.BehavioralPattern{
					Name:        pattern.Name,
					Type:        models.PatternType(pattern.Type),
					Weight:      pattern.Weight,
					Description: pattern.Description,
					Match:       matchDisplay,
					Category:    pattern.Category,
				})
			}
		}
	}
	
	return detected
}

func (ma *MalwareAnalyzer) checkSuspiciousStrings(content string) []models.BehavioralPattern {
	var detected []models.BehavioralPattern
	contentLower := strings.ToLower(content)
	
	for _, suspicious := range ma.suspiciousStrings {
		if strings.Contains(contentLower, suspicious) {
			detected = append(detected, models.BehavioralPattern{
				Name:   "Suspicious String Detected",
				Type:   "Indicator",
				Weight: 50,
				Details: fmt.Sprintf("Found: %s", suspicious),
			})
		}
	}
	
	return detected
}

func (ma *MalwareAnalyzer) detectScriptType(content string) string {
	// Check for shebang
	if strings.HasPrefix(content, "#!") {
		if strings.Contains(strings.ToLower(content), "bash") ||
		   strings.Contains(strings.ToLower(content), "sh") ||
		   strings.Contains(strings.ToLower(content), "zsh") {
			return "Shell"
		}
		if strings.Contains(strings.ToLower(content), "python") {
			return "Python"
		}
		if strings.Contains(strings.ToLower(content), "perl") {
			return "Perl"
		}
	}
	
	// Check for JavaScript indicators
	jsIndicators := []string{
		"function", "var ", "let ", "const ", "document.",
		"window.", "console.", "alert(", "setTimeout",
		"addEventListener", "getElementById", "</script>",
		"eval(", "atob(",
	}
	
	for _, indicator := range jsIndicators {
		if strings.Contains(content, indicator) {
			return "JavaScript"
		}
	}
	
	// Check for PHP indicators
	if strings.Contains(content, "<?php") || 
	   strings.Contains(content, "<?=") ||
	   strings.Contains(content, "?>") {
		return "PHP"
	}
	
	// Default to generic
	return "Generic"
}

func (ma *MalwareAnalyzer) calculateEntropy(s string) float64 {
	if len(s) == 0 {
		return 0
	}
	
	freq := make(map[rune]int)
	for _, r := range s {
		freq[r]++
	}
	
	var entropy float64
	length := float64(len(s))
	
	for _, count := range freq {
		f := float64(count) / length
		entropy -= f * (f / 2)
	}
	
	return entropy
}

func (ma *MalwareAnalyzer) detectBase64Payload(content string) bool {
	// Look for base64 strings longer than 100 chars
	re := regexp.MustCompile(`[A-Za-z0-9+/]{100,}={0,2}`)
	matches := re.FindAllString(content, -1)
	
	for _, match := range matches {
		// Try to decode to validate
		if _, err := base64.StdEncoding.DecodeString(match); err == nil {
			return true
		}
	}
	
	return false
}

func (ma *MalwareAnalyzer) detectHexPayload(content string) bool {
	// Look for hex strings longer than 64 chars
	re := regexp.MustCompile(`\\x[0-9a-fA-F]{2}`)
	if len(re.FindAllString(content, -1)) > 10 {
		return true
	}
	
	// Look for continuous hex without \x
	re2 := regexp.MustCompile(`[0-9a-fA-F]{64,}`)
	matches := re2.FindAllString(content, -1)
	
	for _, match := range matches {
		// Validate it's actually hex
		if _, err := hex.DecodeString(match); err == nil {
			return true
		}
	}
	
	return false
}

func (ma *MalwareAnalyzer) calculateRiskScore(patterns []models.BehavioralPattern) int {
	if len(patterns) == 0 {
		return 0
	}
	
	var totalScore int
	var maxScore int
	var patternCount int
	
	for _, pattern := range patterns {
		totalScore += pattern.Weight
		if pattern.Weight > maxScore {
			maxScore = pattern.Weight
		}
		patternCount++
	}
	
	// Weighted calculation: 60% from highest severity, 40% from average
	averageScore := totalScore / patternCount
	riskScore := int(float64(maxScore)*0.6 + float64(averageScore)*0.4)
	
	if riskScore > 100 {
		return 100
	}
	
	return riskScore
}

func (ma *MalwareAnalyzer) determineSeverity(score int) string {
	switch {
	case score >= 90:
		return "CRITICAL"
	case score >= 70:
		return "HIGH"
	case score >= 50:
		return "MEDIUM"
	case score >= 30:
		return "LOW"
	default:
		return "INFO"
	}
}

func (ma *MalwareAnalyzer) calculateConfidence(patterns []models.BehavioralPattern) int {
	if len(patterns) == 0 {
		return 0
	}
	
	// Confidence increases with number of different patterns
	patternTypes := make(map[string]bool)
	for _, pattern := range patterns {
		patternTypes[string(pattern.Type)] = true
	}
	
	confidence := len(patternTypes) * 15
	if confidence > 100 {
		return 100
	}
	
	return confidence
}

func (ma *MalwareAnalyzer) generateCacheKey(content string) string {
	// Use SHA256 of content as cache key
	hash := sha256.New()
	hash.Write([]byte(content))
	return hex.EncodeToString(hash.Sum(nil))
}

func (ma *MalwareAnalyzer) getFromCache(key string) (*models.BehaviorAnalysis, bool) {
	ma.mu.RLock()
	defer ma.mu.RUnlock()
	
	if analysis, found := ma.signatureCache[key]; found {
		// Check if cache is still valid (5 minutes)
		if time.Since(analysis.Timestamp) < 5*time.Minute {
			return analysis, true
		}
		// Remove expired cache
		delete(ma.signatureCache, key)
	}
	
	return nil, false
}

func (ma *MalwareAnalyzer) addToCache(key string, analysis *models.BehaviorAnalysis) {
	ma.mu.Lock()
	defer ma.mu.Unlock()
	
	// Limit cache size
	if len(ma.signatureCache) >= 1000 {
		// Remove oldest entry (simplified - in production use LRU)
		for k := range ma.signatureCache {
			delete(ma.signatureCache, k)
			break
		}
	}
	
	ma.signatureCache[key] = analysis
}

// AnalyzeFile analyzes a file on disk
func (ma *MalwareAnalyzer) AnalyzeFile(filePath string) (*models.BehaviorAnalysis, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()
	
	// Get file info
	fileInfo, err := file.Stat()
	if err != nil {
		return nil, fmt.Errorf("failed to get file info: %w", err)
	}
	
	// Read first 1MB for analysis (enough for most scripts)
	buffer := make([]byte, 1024*1024)
	n, err := file.Read(buffer)
	if err != nil && err != io.EOF {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}
	
	content := string(buffer[:n])
	
	// Calculate file hashes
	hashes, err := ma.calculateFileHashes(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to calculate hashes: %w", err)
	}
	
	// Analyze content
	analysis := ma.AnalyzeScript(content)
	
	// Check against known malicious hashes
	for hashType, hashValue := range hashes {
		if sig, found := ma.maliciousHashes[hashValue]; found {
			analysis.Patterns = append(analysis.Patterns, models.BehavioralPattern{
				Name:   fmt.Sprintf("Known Malware: %s", sig.Name),
				Type:   models.PatternMalware,
				Weight: ma.weights[sig.Severity],
				Details: fmt.Sprintf("%s: %s", hashType, hashValue),
			})
		}
	}
	
	// Add file metadata
	analysis.FileSize = fileInfo.Size()
	analysis.FileName = fileInfo.Name()
	analysis.FileHashes = hashes
	
	// Recalculate with signature matches
	if len(analysis.Patterns) > 0 {
		analysis.RiskScore = ma.calculateRiskScore(analysis.Patterns)
		analysis.Severity = ma.determineSeverity(analysis.RiskScore)
		analysis.Confidence = float64(ma.calculateConfidence(analysis.Patterns))
	}
	
	return analysis, nil
}

func (ma *MalwareAnalyzer) calculateFileHashes(filePath string) (map[string]string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	
	hashers := []hash.Hash{
		md5.New(),
		sha1.New(),
		sha256.New(),
	}
	
	multiWriter := io.MultiWriter(hashers[0], hashers[1], hashers[2])
	
	// Reset file pointer
	file.Seek(0, 0)
	
	if _, err := io.Copy(multiWriter, file); err != nil {
		return nil, err
	}
	
	return map[string]string{
		"MD5":    hex.EncodeToString(hashers[0].Sum(nil)),
		"SHA1":   hex.EncodeToString(hashers[1].Sum(nil)),
		"SHA256": hex.EncodeToString(hashers[2].Sum(nil)),
	}, nil
}

// AddMalwareSignature adds a new malware signature to the database
func (ma *MalwareAnalyzer) AddMalwareSignature(signature MalwareSignature) {
	ma.mu.Lock()
	defer ma.mu.Unlock()
	
	ma.maliciousHashes[signature.Hash] = signature
}

// RemoveMalwareSignature removes a malware signature
func (ma *MalwareAnalyzer) RemoveMalwareSignature(hash string) {
	ma.mu.Lock()
	defer ma.mu.Unlock()
	
	delete(ma.maliciousHashes, hash)
}

// GetMalwareSignatures returns all known malware signatures
func (ma *MalwareAnalyzer) GetMalwareSignatures() []MalwareSignature {
	ma.mu.RLock()
	defer ma.mu.RUnlock()
	
	signatures := make([]MalwareSignature, 0, len(ma.maliciousHashes))
	for _, sig := range ma.maliciousHashes {
		signatures = append(signatures, sig)
	}
	
	return signatures
}

// AnalyzeFileHash checks if a file hash is known to be malicious
func (ma *MalwareAnalyzer) AnalyzeFileHash(fileHash string) *models.BehaviorAnalysis {
	analysis := &models.BehaviorAnalysis{
		Patterns:   make([]models.BehavioralPattern, 0),
		RiskScore:  0,
		Severity:   "INFO",
		Confidence: 0,
		Timestamp:  time.Now(),
	}
	
	// Validate hash format
	if !ma.isValidHash(fileHash) {
		analysis.Patterns = append(analysis.Patterns, models.BehavioralPattern{
			Name:   "Invalid Hash Format",
			Type:   "Validation Error",
			Weight: 0,
			Details: fmt.Sprintf("Hash: %s", fileHash),
		})
		return analysis
	}
	
	ma.mu.RLock()
	sig, found := ma.maliciousHashes[fileHash]
	ma.mu.RUnlock()
	
	if found {
		analysis.Patterns = append(analysis.Patterns, models.BehavioralPattern{
			Name:   fmt.Sprintf("Known Malware: %s", sig.Name),
			Type:   models.PatternMalware,
			Weight: ma.weights[sig.Severity],
			Details: fmt.Sprintf("Family: %s, First Seen: %s", sig.Family, sig.FirstSeen.Format("2006-01-02")),
		})
		analysis.RiskScore = ma.weights[sig.Severity]
		analysis.Severity = sig.Severity
		analysis.Confidence = 95
	} else {
		analysis.Patterns = append(analysis.Patterns, models.BehavioralPattern{
			Name:   "Unknown Hash",
			Type:   models.PatternType("Unknown"),
			Weight: 0,
			Details: "Hash not found in malware database",
		})
	}
	
	return analysis
}

func (ma *MalwareAnalyzer) isValidHash(hash string) bool {
	// Check if string contains only hex characters
	re := regexp.MustCompile(`^[0-9a-fA-F]+$`)
	if !re.MatchString(hash) {
		return false
	}
	
	// Check length for common hash types
	switch len(hash) {
	case 32:  // MD5
		return true
	case 40:  // SHA1
		return true
	case 64:  // SHA256
		return true
	default:
		return false
	}
}
